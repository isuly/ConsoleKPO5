using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleKPO5
{
    class HeapSort
    {
        //конструктор
        public HeapSort()
        { }
        //метод сортировки (получает массив и его размер), возвращает отсортированный массив
        public int[] Sort(int[] mass, int size)
        {
            //ЭТАП 1: 
            //для каждого элемента массива находится его новое расположение в массиве таким образом, чтобы выполнялись условия пирамиды.

            int i = size / 2 - 1; //разделяем исходный массив на две половины: левую с индексами от 0 до[n / 2]-1, и правую с индексами от[n / 2] до n-1
            int max = 0, temp = 0, num = 0, p1 = 0, p2 = 0;//temp - переменная для выполнения пересылок
            bool stop = false;
            while (i >= 0) //перебираем первую часть массива с конца
            {

                //   * Выбираем потомки iго элемента с индексами [2 * i + 1] и [2 * i + 2] и проверяем их принадлежность массиву
                if ((2 * i + 1 <= size - 1) && (2 * i + 2 <= size - 1))
                {
                    //присваиваем их временным переменным
                    p1 = mass[2 * i + 1];
                    p2 = mass[2 * i + 2];
                }
                else
                {
                    //если только 1 из потомков принадлежит массиву
                    if (2 * i + 1 <= size - 1)
                    {
                        p1 = mass[2 * i + 1];
                        p2 = p1 - 1;
                    }
                }

                if (p1 > p2)// выбираем из них наибольший
                {
                    //назначаем максимальным р1
                    max = p1;
                    num = 2 * i + 1;
                }
                else
                {
                    //назначаем максимальным р2
                    max = p2;
                    num = 2 * i + 2;
                }
                //сравниваем элемент текущий элемент из левой части с наибольшим из потомков: 
                if (mass[i] < max)
                {
                    //если он меньше, то меняем эти элементы в массиве местами для получения фрагмента пирамиды; 
                    if (num > size / 2 - 1) //если обмент совершается с потомком который сам не имеет потомков
                    {
                        //элемент и его потомок меняются местами
                        temp = mass[i];
                        mass[i] = mass[num];
                        mass[num] = temp;
                    }
                    else  //В противном случае:(у потомка элемента с которым призводится обмен есть свои потомки)
                    {

                        //элемент и его потомок меняются местами
                        temp = mass[i];
                        mass[i] = mass[num];
                        mass[num] = temp;
                        int j = num;
                        //объявляем флаг для оставновки перебора потомков
                        stop = false;
                        //проверяем выполнение условия (элемент больше большего потомка) пока не достигнем дна пирамиды или пока флаг не будет равен 1:
                        while ((2 * j + 1 <= size - 1) && (stop != true))
                        {
                            //определяем больший из его потомков
                            p1 = mass[2 * j + 1];
                            if (2 * j + 2 <= size - 1)
                            {
                                p2 = mass[2 * j + 2];

                                if (p1 > p2)
                                {
                                    max = p1;
                                    num = 2 * j + 1;
                                }
                                else
                                {
                                    max = p2;
                                    num = 2 * j + 2;
                                }
                            }
                            else
                            {
                                max = p1;
                                num = 2 * j + 1;
                            }

                            if (mass[j] < max) //если условие пирамиды не выполняется
                            {
                                //меняем их местами
                                temp = mass[j];
                                mass[j] = mass[num];
                                mass[num] = temp;
                                j = num;
                            }
                            else //если условие выполняется (элемент больше его потомков)
                            {
                                //устанавливаем флаг остановки в 1
                                stop = true;
                            }
                        }
                        stop = false;
                    }
                }
                else
                {
                    //в противном случае оставляем все  без изменений
                }


                i--;
            }

            ////ЭТАП 2
            ////ПРОСЕИВАНИЕ ЧЕРЕЗ ПИРАМИДУ

            ///*Для всех элементов массива-пирамиды с конца выполняем просеивание через пирамиду:
            int k = size - 1;
            num = 0; i = 0;
            stop = false;
            while (k > 0)
            {
                //меняем местами первый и последний элемент неотсортированной части массива 
                temp = mass[0];
                mass[0] = mass[k];
                mass[k] = temp;
                k--; //уменьшаем размер неотсортированной части на 1 (последний-больший элемент уже на ствоем месте)

                //просеиваем ставший первым элемент через пирамиду:
                //Пока у элемента есть потомки или пока он не встанет на свое место:
                while ((2 * i + 1 <= k) && (stop == false))
                {

                    //выбирам наибольший из его потомков
                    if (2 * i + 2 <= k)
                    {
                        if (mass[2 * i + 1] < mass[2 * i + 2])
                        {
                            num = 2 * i + 2;
                        }
                        else
                        {
                            num = 2 * i + 1;
                        }
                    }
                    else
                    {
                        num = 2 * i + 1;
                    }

                    //сравниваем просеиваемый элемент с наибольшим потомком
                    //если просеиваемый элемент меньше большего потомка
                    if (mass[i] <= mass[num])
                    {
                        //меняем их местами
                        temp = mass[num];
                        mass[num] = mass[i];
                        mass[i] = temp;
                        i = num;
                    }
                
                    else //если просеиваемый элемент больше обоих потомков
                    {
                        //устанавливаем флаг остановки в 1
                        stop = true;
                    }
                }
                stop = false;
                i = 0;
            }

            return mass;
           // return mass;
        }
    }
}
