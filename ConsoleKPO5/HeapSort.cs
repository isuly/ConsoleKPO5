using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleKPO5
{
    class HeapSort
    {
        //конструктор
        public HeapSort()
        { }
        //метод сортировки (получает массив и его размер), возвращает отсортированный массив
        public int[] Sort(int[] mass, int size)
        {
            //ЭТАП 1: 
            //для каждого элемента массива находится его новое расположение в массиве таким образом, чтобы выполнялись условия пирамиды.

            int i = size / 2 - 1; //разделяем исходный массив на две половины: левую с индексами от 0 до[n / 2]-1, и правую с индексами от[n / 2] до n-1
            int max = 0, temp = 0, num = 0, p1 = 0, p2 = 0;//temp - переменная для выполнения пересылок
            bool stop = false;
            while (i >= 0) //перебираем первую часть массива с конца
            {

                //   * Выбираем потомки iго элемента с индексами [2 * i + 1] и [2 * i + 2] и проверяем их принадлежность массиву
                if ((2 * i + 1 <= size - 1) && (2 * i + 2 <= size - 1))
                {
                    //присваиваем их временным переменным
                }
                else
                {
                    //если только 1 из потомков принадлежит массиву
                }

                if (p1 > p2)// выбираем из них наибольший
                {
                    //назначаем максимальным р1
                }
                else
                {
                    //назначаем максимальным р2
                }
                //сравниваем элемент текущий элемент из левой части с наибольшим из потомков: 
                if (mass[i] < max)
                {
                    //если он меньше, то меняем эти элементы в массиве местами для получения фрагмента пирамиды; 
                    if (num > size / 2 - 1) //если обмент совершается с потомком который сам не имеет потомков
                    {
                        //элемент и его потомок меняются местами
                    }
                    else  //В противном случае:(у потомка элемента с которым призводится обмен есть свои потомки)
                    {

                        //элемент и его потомок меняются местами

                        int j = 0;
                        //объявляем флаг для оставновки перебора потомков
                        stop = false;
                        //проверяем выполнение условия (элемент больше большего потомка) пока не достигнем дна пирамиды или пока флаг не будет равен 1:
                        while ((2 * j + 1 <= size - 1) && (stop != true))
                        {
                            //определяем больший из его потомков
                            if (mass[j] < max) //если условие пирамиды не выполняется
                            {
                                //меняем их местами
                            }
                            else //если условие выполняется (элемент больше его потомков)
                            {
                                //устанавливаем флаг остановки в 1
                            }
                        }
                    }
                }
                else
                {
                    //в противном случае оставляем все  без изменений
                }


                i--;
            }

            ////ЭТАП 2
            ////ПРОСЕИВАНИЕ ЧЕРЕЗ ПИРАМИДУ

            ///*Для всех элементов массива-пирамиды с конца выполняем просеивание через пирамиду:
            int k = size - 1;
            stop = false;
            while (k > 0)
            {
                //меняем местами первый и последний элемент неотсортированной части массива 

                k--; //уменьшаем размер неотсортированной части на 1 (последний-больший элемент уже на ствоем месте)

                //просеиваем ставший первым элемент через пирамиду:
                //Пока у элемента есть потомки или пока он не встанет на свое место:
                while ((2 * i + 1 <= k) && (stop == false))
                {

                    //выбирам наибольший из его потомков
                    //сравниваем просеиваемый элемент с наибольшим потомком
                    //если просеиваемый элемент меньше большего потомка
                    if (mass[i] <= mass[num])
                    {
                        //меняем их местами
                    }
                    else //если просеиваемый элемент больше обоих потомков
                    {
                        //устанавливаем флаг остановки в 1
                    }
                }

            }

            return mass;
           // return mass;
        }
    }
}
